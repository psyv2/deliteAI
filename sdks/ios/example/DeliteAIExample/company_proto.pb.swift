/*
 * SPDX-FileCopyrightText: (C) 2025 DeliteAI Authors
 *
 * SPDX-License-Identifier: Apache-2.0
 */

// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: updated_proto.pb
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Generated_Address: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var street: String = String()

  var city: String = String()

  var state: String = String()

  var zipCode: String = String()

  /// Stores extra details about the address
  var additionalInfo: Dictionary<String,String> = [:]

  var buildings: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Generated_EmailAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var email: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Generated_Company: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var companyID: String = String()

  var companyName: String = String()

  var departments: [Generated_Company.Department] = []

  var global: Bool = false

  var officePincodes: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Department: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var departmentID: Int64 = 0

    var departmentName: String = String()

    var employees: [Generated_Company.Department.Employee] = []

    var revenue: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Employee: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var employeeID: String = String()

      var name: String = String()

      var title: String {
        get {return _title ?? String()}
        set {_title = newValue}
      }
      /// Returns true if `title` has been explicitly set.
      var hasTitle: Bool {return self._title != nil}
      /// Clears the value of `title`. Subsequent reads from it will return its default value.
      mutating func clearTitle() {self._title = nil}

      var contactInfo: Generated_Company.Department.Employee.ContactInfo {
        get {return _contactInfo ?? Generated_Company.Department.Employee.ContactInfo()}
        set {_contactInfo = newValue}
      }
      /// Returns true if `contactInfo` has been explicitly set.
      var hasContactInfo: Bool {return self._contactInfo != nil}
      /// Clears the value of `contactInfo`. Subsequent reads from it will return its default value.
      mutating func clearContactInfo() {self._contactInfo = nil}

      var projects: [Generated_Company.Department.Employee.Project] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct ContactInfo: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var phone: String = String()

        var address: SwiftProtobuf.Google_Protobuf_Any {
          get {return _address ?? SwiftProtobuf.Google_Protobuf_Any()}
          set {_address = newValue}
        }
        /// Returns true if `address` has been explicitly set.
        var hasAddress: Bool {return self._address != nil}
        /// Clears the value of `address`. Subsequent reads from it will return its default value.
        mutating func clearAddress() {self._address = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _address: SwiftProtobuf.Google_Protobuf_Any? = nil
      }

      struct Project: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var projectID: String = String()

        var projectName: String = String()

        var role: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}

      fileprivate var _title: String? = nil
      fileprivate var _contactInfo: Generated_Company.Department.Employee.ContactInfo? = nil
    }

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "generated"

extension Generated_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Address"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "street"),
    2: .same(proto: "city"),
    3: .same(proto: "state"),
    4: .standard(proto: "zip_code"),
    5: .standard(proto: "additional_info"),
    6: .same(proto: "buildings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.street) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.city) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.zipCode) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.additionalInfo) }()
      case 6: try { try decoder.decodeRepeatedInt32Field(value: &self.buildings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.street.isEmpty {
      try visitor.visitSingularStringField(value: self.street, fieldNumber: 1)
    }
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 2)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 3)
    }
    if !self.zipCode.isEmpty {
      try visitor.visitSingularStringField(value: self.zipCode, fieldNumber: 4)
    }
    if !self.additionalInfo.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.additionalInfo, fieldNumber: 5)
    }
    if !self.buildings.isEmpty {
      try visitor.visitPackedInt32Field(value: self.buildings, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Generated_Address, rhs: Generated_Address) -> Bool {
    if lhs.street != rhs.street {return false}
    if lhs.city != rhs.city {return false}
    if lhs.state != rhs.state {return false}
    if lhs.zipCode != rhs.zipCode {return false}
    if lhs.additionalInfo != rhs.additionalInfo {return false}
    if lhs.buildings != rhs.buildings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Generated_EmailAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EmailAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Generated_EmailAddress, rhs: Generated_EmailAddress) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Generated_Company: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Company"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "company_id"),
    2: .standard(proto: "company_name"),
    3: .same(proto: "departments"),
    4: .same(proto: "global"),
    5: .standard(proto: "office_pincodes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.companyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.companyName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.departments) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.global) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.officePincodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.companyID.isEmpty {
      try visitor.visitSingularStringField(value: self.companyID, fieldNumber: 1)
    }
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 2)
    }
    if !self.departments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.departments, fieldNumber: 3)
    }
    if self.global != false {
      try visitor.visitSingularBoolField(value: self.global, fieldNumber: 4)
    }
    if !self.officePincodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.officePincodes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Generated_Company, rhs: Generated_Company) -> Bool {
    if lhs.companyID != rhs.companyID {return false}
    if lhs.companyName != rhs.companyName {return false}
    if lhs.departments != rhs.departments {return false}
    if lhs.global != rhs.global {return false}
    if lhs.officePincodes != rhs.officePincodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Generated_Company.Department: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Generated_Company.protoMessageName + ".Department"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "department_id"),
    2: .standard(proto: "department_name"),
    3: .same(proto: "employees"),
    4: .same(proto: "revenue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.departmentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.departmentName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.employees) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.revenue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.departmentID != 0 {
      try visitor.visitSingularInt64Field(value: self.departmentID, fieldNumber: 1)
    }
    if !self.departmentName.isEmpty {
      try visitor.visitSingularStringField(value: self.departmentName, fieldNumber: 2)
    }
    if !self.employees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.employees, fieldNumber: 3)
    }
    if self.revenue.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.revenue, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Generated_Company.Department, rhs: Generated_Company.Department) -> Bool {
    if lhs.departmentID != rhs.departmentID {return false}
    if lhs.departmentName != rhs.departmentName {return false}
    if lhs.employees != rhs.employees {return false}
    if lhs.revenue != rhs.revenue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Generated_Company.Department.Employee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Generated_Company.Department.protoMessageName + ".Employee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "employee_id"),
    2: .same(proto: "name"),
    3: .same(proto: "title"),
    4: .standard(proto: "contact_info"),
    5: .same(proto: "projects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.employeeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._contactInfo) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.projects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.employeeID.isEmpty {
      try visitor.visitSingularStringField(value: self.employeeID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._contactInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.projects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.projects, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Generated_Company.Department.Employee, rhs: Generated_Company.Department.Employee) -> Bool {
    if lhs.employeeID != rhs.employeeID {return false}
    if lhs.name != rhs.name {return false}
    if lhs._title != rhs._title {return false}
    if lhs._contactInfo != rhs._contactInfo {return false}
    if lhs.projects != rhs.projects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Generated_Company.Department.Employee.ContactInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Generated_Company.Department.Employee.protoMessageName + ".ContactInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    try { if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Generated_Company.Department.Employee.ContactInfo, rhs: Generated_Company.Department.Employee.ContactInfo) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Generated_Company.Department.Employee.Project: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Generated_Company.Department.Employee.protoMessageName + ".Project"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "project_name"),
    3: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.projectName.isEmpty {
      try visitor.visitSingularStringField(value: self.projectName, fieldNumber: 2)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Generated_Company.Department.Employee.Project, rhs: Generated_Company.Department.Employee.Project) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.projectName != rhs.projectName {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
